# 规范驱动开发：从Vibe Coding到SDD

## 一、什么是SDD

**规范驱动开发 (Specification-Driven Development, SDD)** 是一种软件开发方法，强调在编写任何实际代码之前，必须首先编写一份详尽、精确、可执行的规范。

SDD的核心理念是{==文档先行==}——确保开发者与AI之间有共同的事实来源，以便更好地协作和验证代码的正确性。这种方法通过形式化规范引导AI生成生产级代码，从而显著提升代码质量与开发效率。

## 二、SDD的核心理念

### 2.1 文档先行

传统软件开发中，文档往往是在代码之后才撰写的，或者根本不写。SDD则彻底颠覆这一流程：

```
传统流程: 需求 → 代码 → 测试 → 文档 (可选)
SDD流程:    需求 → 规范 → 代码 → 测试 → 验证
```

### 2.2 共同的事实来源

SDD创建了一个单一的事实来源 (Single Source of Truth)，确保：

- 开发者对需求的理解与AI一致
- 规范可作为契约，约束代码生成
- 便于后续维护和迭代

### 2.3 可执行的规范

SDD的规范不是简单的需求描述，而是：

- **精确的**：消除歧义，明确边界条件
- **结构化的**：便于AI解析和理解
- **可验证的**：可用于自动验证生成的代码

## 三、为什么要用SDD

### 3.1 传统AI代码生成的局限性

当直接让AI"写一个用户登录功能"时，往往面临以下问题：

| 问题 | 描述 |
|------|------|
| 需求不明确 | AI不知道需要哪些字段、验证规则、错误处理 |
| 上下文缺失 | AI不了解整体架构、数据模型、依赖关系 |
| 代码不一致 | 不同轮对话生成的代码风格和结构差异大 |
| 难以验证 | 没有明确的标准来判断代码是否符合需求 |
| 维护困难 | 后续修改时需要重新解释整个需求 |

### 3.2 SDD的优势

通过SDD，这些问题可以得到有效解决：

```
┌─────────────────────────────────────────────────────────────┐
│                    SDD 带来的价值                            │
├─────────────────┬───────────────────────────────────────────┤
│ 提升代码质量     │ 规范作为约束条件，确保生成的代码符合预期     │
│ 提高开发效率     │ 减少反复沟通，一次性生成可用的代码          │
│ 降低维护成本     │ 规范即文档，便于理解和修改                  │
│ 增强可测试性     │ 规范可直接转换为测试用例                    │
│ 支持团队协作     │ 共同的规范确保团队成员理解一致              │
└─────────────────┴───────────────────────────────────────────┘
```

和TDD或BDD相比，SDD将视角进一步前移，先明确“做什么、为什么做”，再进入实现环节。

与MDD相比，SDD更加灵活：它常用自然语言或结构化Markdown来描述需求，同时借助LLM将文本映射为代码与系统配置，减少格式化模型与具体实现之间的摩擦。

## 四、SDD的实践（代表性工具与项目）

### 4.1 Kiro

Kiro 是轻量级 VS Code 插件，遵循 Requirements → Design → Tasks 流程。其特点是直观但繁琐，适合一次性任务。

### 4.2 Spec-kit

Spec-kit 是 GitHub 出品的 CLI 套件。其核心概念为 Constitution（宪章）——定义架构原则。流程为 Constitution → Specify → Plan → Tasks。该工具仍偏向 spec-first，但为团队协作提供模板化结构。

### 4.3 Tessl Framework

Tessl Framework 是实验性框架，支持从代码反推规范（tessl document --code）。生成的代码带有 // GENERATED FROM SPEC – DO NOT EDIT 标记。支持 @generate, @test 等标签控制生成逻辑，是向 spec-as-source 迈进的早期形态。

### 4.4 Qoder

Qoder 是一个专为 SDD 场景设计的 AI 编程助手，强调“规范即代码”的理念。它支持以结构化 Markdown 编写规范，自动生成项目结构、代码和测试用例，并通过多轮对话协助开发者完善和演进规范。Qoder 集成了 LLM、代码生成、测试与部署等能力，适合团队协作和复杂工程场景，致力于让 AI 成为规范驱动开发流程中的主动参与者和执行者。

### 4.5 LangChain Expression Language (LCEL)

LCEL 为 LangChain 提供了一种声明式 DSL，允许用管道语法描述 LLM 工作流——“说明要发生什么”而非细节如何实现。它在微观层面提供了声明式的规格驱动方法，使 LLM 工具的编排更直观和可维护。

### 4.6 OpenDevin

OpenDevin 致力于构建能够读写代码、运行命令、访问网页的自主 AI 工程师。其框架强调任务规划、沙箱执行与权限控制，体现了 SDD 对可控性与治理的要求。目前仍在早期，但演示了端到端自动构建应用的可能性。

### 4.7 AgentScript

AgentScript 的特色在于让 LLM 输出一段“计划代码”（类似 JavaScript），将其解析成 AST，由运行时逐步执行。计划显式化、可审查、可暂停、可序列化，从而提高 Agent 的可解释性与可控性。这是一种让“规范驱动代理行为”的设计。

### 4.8 CodePlan

CodePlan 是学术界提出的框架，将大规模代码变更视作规划问题：AI 产出一个带依赖关系的计划图，逐步修改并在每步后用构建/测试/静态检查等验证。如果验证失败，反馈回 AI 重新规划。这种“先计划再行动”策略提高了在复杂代码库中改动的成功率，是 SDD 在研究领域的前沿探索之一。

## Reference

[规范驱动开发（SDD）简介：从氛围编程到 SDD](https://jimmysong.io/zh/book/ai-handbook/sdd/overview/)

[一文带你深入理解AI时代软件开发新范式-SDD(规范驱动开发）和对应的开发框架开源框架SPEC KIT](https://zhuanlan.zhihu.com/p/1973155725061682707)

[Specification-Driven Development (SDD) - 规范驱动开发](https://hobbytp.github.io/zh/projects/code_assistant/spec-driven-dev/)

